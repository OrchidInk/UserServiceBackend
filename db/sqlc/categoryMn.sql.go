// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: categoryMn.sql

package db

import (
	"context"
)

const createCategoryMn = `-- name: CreateCategoryMn :one
INSERT INTO
    "categoryMn" ("CategoryNameMn")
VALUES
    (
        "CategoryNameMn" = $1 :: VARCHAR(100)
    ) RETURNING "CategoryMnID", "CategoryNameMn"
`

func (q *Queries) CreateCategoryMn(ctx context.Context, categorynamemn string) (CategoryMn, error) {
	row := q.db.QueryRowContext(ctx, createCategoryMn, categorynamemn)
	var i CategoryMn
	err := row.Scan(&i.CategoryMnID, &i.CategoryNameMn)
	return i, err
}

const deleteFromCategoryMn = `-- name: DeleteFromCategoryMn :exec
DELETE FROM
    "categoryMn"
WHERE
    "CategoryMnID" = $1
`

func (q *Queries) DeleteFromCategoryMn(ctx context.Context, categorymnid int32) error {
	_, err := q.db.ExecContext(ctx, deleteFromCategoryMn, categorymnid)
	return err
}

const findByIdCategoryMn = `-- name: FindByIdCategoryMn :one
SELECT
    "CategoryMnID", "CategoryNameMn"
FROM
    "categoryMn"
WHERE
    "CategoryMnID" - $1
LIMIT
    1
`

func (q *Queries) FindByIdCategoryMn(ctx context.Context, categorymnid int32) (CategoryMn, error) {
	row := q.db.QueryRowContext(ctx, findByIdCategoryMn, categorymnid)
	var i CategoryMn
	err := row.Scan(&i.CategoryMnID, &i.CategoryNameMn)
	return i, err
}

const findByNameCategoryMn = `-- name: FindByNameCategoryMn :one
SELECT
    "CategoryMnID", "CategoryNameMn"
FROM
    "categoryMn"
WHERE
    "CategoryNameMn" = $1
LIMIT
    1
`

func (q *Queries) FindByNameCategoryMn(ctx context.Context, categorynamemn string) (CategoryMn, error) {
	row := q.db.QueryRowContext(ctx, findByNameCategoryMn, categorynamemn)
	var i CategoryMn
	err := row.Scan(&i.CategoryMnID, &i.CategoryNameMn)
	return i, err
}

const getByIdCategoryMn = `-- name: GetByIdCategoryMn :one
SELECT
    "CategoryMnID", "CategoryNameMn"
FROM
    "categoryMn"
WHERE
    "CategoryMnID" = $1
LIMIT
    1
`

func (q *Queries) GetByIdCategoryMn(ctx context.Context, categorymnid int32) (CategoryMn, error) {
	row := q.db.QueryRowContext(ctx, getByIdCategoryMn, categorymnid)
	var i CategoryMn
	err := row.Scan(&i.CategoryMnID, &i.CategoryNameMn)
	return i, err
}

const getListAllCategoryMn = `-- name: GetListAllCategoryMn :many
SELECT
    "CategoryMnID", "CategoryNameMn"
FROM
    "categoryMn"
`

func (q *Queries) GetListAllCategoryMn(ctx context.Context) ([]CategoryMn, error) {
	rows, err := q.db.QueryContext(ctx, getListAllCategoryMn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CategoryMn
	for rows.Next() {
		var i CategoryMn
		if err := rows.Scan(&i.CategoryMnID, &i.CategoryNameMn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateByCategoryMn = `-- name: UpdateByCategoryMn :exec
UPDATE
    "categoryMn"
SET
    "CategoryNameMn" = $1 :: VARCHAR(100)
WHERE
    "CategoryMnID" = $2
`

type UpdateByCategoryMnParams struct {
	CategoryNameMn string
	CategoryMnID   int32
}

func (q *Queries) UpdateByCategoryMn(ctx context.Context, arg UpdateByCategoryMnParams) error {
	_, err := q.db.ExecContext(ctx, updateByCategoryMn, arg.CategoryNameMn, arg.CategoryMnID)
	return err
}
