// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: productEn.sql

package db

import (
	"context"
	"database/sql"
)

const createProductEn = `-- name: CreateProductEn :one
INSERT INTO
    "productEn" (
        "ProductNameEn",
        "subCategoryIDEn",
        "PriceEn",
        "StockQuantity",
        "ImagesPathEn"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5
    ) RETURNING "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
`

type CreateProductEnParams struct {
	ProductNameEn   string
	SubCategoryIDEn int32
	PriceEn         string
	StockQuantity   int32
	ImagesPathEn    string
}

func (q *Queries) CreateProductEn(ctx context.Context, arg CreateProductEnParams) (ProductEn, error) {
	row := q.db.QueryRowContext(ctx, createProductEn,
		arg.ProductNameEn,
		arg.SubCategoryIDEn,
		arg.PriceEn,
		arg.StockQuantity,
		arg.ImagesPathEn,
	)
	var i ProductEn
	err := row.Scan(
		&i.ProductEnID,
		&i.ProductNameEn,
		&i.SubCategoryIDEn,
		&i.PriceEn,
		&i.StockQuantity,
		&i.ImagesPathEn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deductStockQuantityByProductEnID = `-- name: DeductStockQuantityByProductEnID :one
UPDATE
    "productEn"
SET
    "StockQuantity" = "StockQuantity" - $1
WHERE
    "ProductEnID" = $2
    AND "StockQuantity" >= $1 RETURNING "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
`

type DeductStockQuantityByProductEnIDParams struct {
	QuantityPurchased int32
	ProductEnID       int32
}

func (q *Queries) DeductStockQuantityByProductEnID(ctx context.Context, arg DeductStockQuantityByProductEnIDParams) (ProductEn, error) {
	row := q.db.QueryRowContext(ctx, deductStockQuantityByProductEnID, arg.QuantityPurchased, arg.ProductEnID)
	var i ProductEn
	err := row.Scan(
		&i.ProductEnID,
		&i.ProductNameEn,
		&i.SubCategoryIDEn,
		&i.PriceEn,
		&i.StockQuantity,
		&i.ImagesPathEn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteByProductEnId = `-- name: DeleteByProductEnId :exec
DELETE FROM
    "productEn"
WHERE
    "ProductEnID" = $1
`

func (q *Queries) DeleteByProductEnId(ctx context.Context, productenid int32) error {
	_, err := q.db.ExecContext(ctx, deleteByProductEnId, productenid)
	return err
}

const filterByProductEnName = `-- name: FilterByProductEnName :many
SELECT
    "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
FROM
    "productEn"
WHERE
    "ProductEnName" ILIKE '%' || $1 || '%' -- Case-insensitive search for partial match
ORDER BY
    "Created_At" DESC
`

func (q *Queries) FilterByProductEnName(ctx context.Context, productenname sql.NullString) ([]ProductEn, error) {
	rows, err := q.db.QueryContext(ctx, filterByProductEnName, productenname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductEn
	for rows.Next() {
		var i ProductEn
		if err := rows.Scan(
			&i.ProductEnID,
			&i.ProductNameEn,
			&i.SubCategoryIDEn,
			&i.PriceEn,
			&i.StockQuantity,
			&i.ImagesPathEn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByProductEnID = `-- name: FindByProductEnID :one
SELECT
    "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
FROM
    "productEn"
WHERE
    "ProductEnID" = $1
LIMIT
    1
`

func (q *Queries) FindByProductEnID(ctx context.Context, productenid int32) (ProductEn, error) {
	row := q.db.QueryRowContext(ctx, findByProductEnID, productenid)
	var i ProductEn
	err := row.Scan(
		&i.ProductEnID,
		&i.ProductNameEn,
		&i.SubCategoryIDEn,
		&i.PriceEn,
		&i.StockQuantity,
		&i.ImagesPathEn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findProductWithDetailsByIDEn = `-- name: FindProductWithDetailsByIDEn :many
SELECT
    p."ProductEnID",
    p."ProductNameEn",
    p."subCategoryIDEn",
    p."PriceEn",
    p."StockQuantity",
    p."ImagesPathEn",
    p."Created_At",
    p."Updated_At",
    d."detailEnId",
    d."ChoiceName",
    d."ChoiceValue"
FROM
    "productEn" p
    LEFT JOIN "detailEn" d ON p."ProductEnID" = d."ProductEnID"
WHERE
    p."ProductEnID" = $1
`

type FindProductWithDetailsByIDEnRow struct {
	ProductEnID     int32
	ProductNameEn   string
	SubCategoryIDEn int32
	PriceEn         string
	StockQuantity   int32
	ImagesPathEn    string
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	DetailEnId      sql.NullInt32
	ChoiceName      sql.NullString
	ChoiceValue     sql.NullString
}

func (q *Queries) FindProductWithDetailsByIDEn(ctx context.Context, productenid int32) ([]FindProductWithDetailsByIDEnRow, error) {
	rows, err := q.db.QueryContext(ctx, findProductWithDetailsByIDEn, productenid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindProductWithDetailsByIDEnRow
	for rows.Next() {
		var i FindProductWithDetailsByIDEnRow
		if err := rows.Scan(
			&i.ProductEnID,
			&i.ProductNameEn,
			&i.SubCategoryIDEn,
			&i.PriceEn,
			&i.StockQuantity,
			&i.ImagesPathEn,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DetailEnId,
			&i.ChoiceName,
			&i.ChoiceValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListProductEn = `-- name: GetListProductEn :many
SELECT
    "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
FROM
    "productEn"
ORDER BY
    "Created_At" DESC
`

func (q *Queries) GetListProductEn(ctx context.Context) ([]ProductEn, error) {
	rows, err := q.db.QueryContext(ctx, getListProductEn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductEn
	for rows.Next() {
		var i ProductEn
		if err := rows.Scan(
			&i.ProductEnID,
			&i.ProductNameEn,
			&i.SubCategoryIDEn,
			&i.PriceEn,
			&i.StockQuantity,
			&i.ImagesPathEn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductWithDetailsEn = `-- name: GetProductWithDetailsEn :many
SELECT
    p."ProductEnID",
    p."ProductNameEn",
    p."subCategoryIDEn",
    p."PriceEn",
    p."StockQuantity",
    p."ImagesPathEn",
    p."Created_At",
    p."Updated_At",
    d."detailEnId",
    d."ChoiceName",
    d."ChoiceValue"
FROM
    "productEn" p
    LEFT JOIN "detailEn" d ON p."ProductEnID" = d."ProductEnID"
ORDER BY
    p."ProductEnID",
    d."detailEnId"
`

type GetProductWithDetailsEnRow struct {
	ProductEnID     int32
	ProductNameEn   string
	SubCategoryIDEn int32
	PriceEn         string
	StockQuantity   int32
	ImagesPathEn    string
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	DetailEnId      sql.NullInt32
	ChoiceName      sql.NullString
	ChoiceValue     sql.NullString
}

func (q *Queries) GetProductWithDetailsEn(ctx context.Context) ([]GetProductWithDetailsEnRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductWithDetailsEn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductWithDetailsEnRow
	for rows.Next() {
		var i GetProductWithDetailsEnRow
		if err := rows.Scan(
			&i.ProductEnID,
			&i.ProductNameEn,
			&i.SubCategoryIDEn,
			&i.PriceEn,
			&i.StockQuantity,
			&i.ImagesPathEn,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DetailEnId,
			&i.ChoiceName,
			&i.ChoiceValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateByProductEnImagePath = `-- name: UpdateByProductEnImagePath :one
UPDATE
    "productEn"
SET
    "ImagesPathEn" = $1
WHERE
    "ProductEnID" = $2 RETURNING "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
`

type UpdateByProductEnImagePathParams struct {
	ImagesPathEn string
	ProductEnID  int32
}

func (q *Queries) UpdateByProductEnImagePath(ctx context.Context, arg UpdateByProductEnImagePathParams) (ProductEn, error) {
	row := q.db.QueryRowContext(ctx, updateByProductEnImagePath, arg.ImagesPathEn, arg.ProductEnID)
	var i ProductEn
	err := row.Scan(
		&i.ProductEnID,
		&i.ProductNameEn,
		&i.SubCategoryIDEn,
		&i.PriceEn,
		&i.StockQuantity,
		&i.ImagesPathEn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateByProductEnPrice = `-- name: UpdateByProductEnPrice :one
UPDATE
    "productEn"
SET
    "PriceEn" = $1
WHERE
    "ProductEnID" = $2 RETURNING "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
`

type UpdateByProductEnPriceParams struct {
	PriceEn     string
	ProductEnID int32
}

func (q *Queries) UpdateByProductEnPrice(ctx context.Context, arg UpdateByProductEnPriceParams) (ProductEn, error) {
	row := q.db.QueryRowContext(ctx, updateByProductEnPrice, arg.PriceEn, arg.ProductEnID)
	var i ProductEn
	err := row.Scan(
		&i.ProductEnID,
		&i.ProductNameEn,
		&i.SubCategoryIDEn,
		&i.PriceEn,
		&i.StockQuantity,
		&i.ImagesPathEn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateByProductEnStockQuantity = `-- name: UpdateByProductEnStockQuantity :one
UPDATE
    "productEn"
SET
    "StockQuantity" = $1
WHERE
    "ProductEnID" = $2 RETURNING "ProductEnID", "ProductNameEn", "subCategoryIDEn", "PriceEn", "StockQuantity", "ImagesPathEn", "Created_At", "Updated_At"
`

type UpdateByProductEnStockQuantityParams struct {
	StockQuantity int32
	ProductEnID   int32
}

func (q *Queries) UpdateByProductEnStockQuantity(ctx context.Context, arg UpdateByProductEnStockQuantityParams) (ProductEn, error) {
	row := q.db.QueryRowContext(ctx, updateByProductEnStockQuantity, arg.StockQuantity, arg.ProductEnID)
	var i ProductEn
	err := row.Scan(
		&i.ProductEnID,
		&i.ProductNameEn,
		&i.SubCategoryIDEn,
		&i.PriceEn,
		&i.StockQuantity,
		&i.ImagesPathEn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
