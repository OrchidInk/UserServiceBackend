// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: productMn.sql

package db

import (
	"context"
	"database/sql"
)

const createProductMn = `-- name: CreateProductMn :one
INSERT INTO
    "productMn" (
        "ProductNameMn",
        "sCategoryIdMn",
        "PriceMn",
        "StockQuantity",
        "ImagesPathMn",
        "DescriptionMn",
        "BrandMn",
        "ManufacturedCountryMn",
        "PenOutputMn",
        "FeaturesMn",
        "MaterialMn",
        "StapleSizeMn",
        "CapacityMn",
        "WeightMn",
        "ThicknessMn",
        "PackagingMn",
        "ProductCodeMn",
        "CostPriceMn",
        "RetailPriceMn",
        "WarehouseStockMn"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20
    ) RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type CreateProductMnParams struct {
	ProductNameMn         string
	SCategoryIdMn         int32
	PriceMn               string
	StockQuantity         int32
	ImagesPathMn          string
	DescriptionMn         string
	BrandMn               string
	ManufacturedCountryMn string
	PenOutputMn           string
	FeaturesMn            string
	MaterialMn            string
	StapleSizeMn          string
	CapacityMn            string
	WeightMn              string
	ThicknessMn           string
	PackagingMn           string
	ProductCodeMn         string
	CostPriceMn           string
	RetailPriceMn         string
	WarehouseStockMn      int32
}

func (q *Queries) CreateProductMn(ctx context.Context, arg CreateProductMnParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, createProductMn,
		arg.ProductNameMn,
		arg.SCategoryIdMn,
		arg.PriceMn,
		arg.StockQuantity,
		arg.ImagesPathMn,
		arg.DescriptionMn,
		arg.BrandMn,
		arg.ManufacturedCountryMn,
		arg.PenOutputMn,
		arg.FeaturesMn,
		arg.MaterialMn,
		arg.StapleSizeMn,
		arg.CapacityMn,
		arg.WeightMn,
		arg.ThicknessMn,
		arg.PackagingMn,
		arg.ProductCodeMn,
		arg.CostPriceMn,
		arg.RetailPriceMn,
		arg.WarehouseStockMn,
	)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deductSockQuantityByProductMnID = `-- name: DeductSockQuantityByProductMnID :one
UPDATE
    "productMn"
SET
    "StockQuantity" = "StockQuantity" - $1
WHERE
    "ProductMnID" = $2
    AND "StockQuantity" >= $1 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type DeductSockQuantityByProductMnIDParams struct {
	QuantityPurchased int32
	ProductMnID       int32
}

func (q *Queries) DeductSockQuantityByProductMnID(ctx context.Context, arg DeductSockQuantityByProductMnIDParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, deductSockQuantityByProductMnID, arg.QuantityPurchased, arg.ProductMnID)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteByProductMnId = `-- name: DeleteByProductMnId :exec
DELETE FROM
    "productMn"
WHERE
    "ProductMnID" = $1
`

func (q *Queries) DeleteByProductMnId(ctx context.Context, productmnid int32) error {
	_, err := q.db.ExecContext(ctx, deleteByProductMnId, productmnid)
	return err
}

const filterByProductMnName = `-- name: FilterByProductMnName :many
SELECT
    "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
FROM
    "productMn"
WHERE
    "ProductNameMn" ILIKE '%' || $1 || '%' -- Case-insensitive search for partial match
ORDER BY
    "Created_At" DESC
`

func (q *Queries) FilterByProductMnName(ctx context.Context, productnamemn sql.NullString) ([]ProductMn, error) {
	rows, err := q.db.QueryContext(ctx, filterByProductMnName, productnamemn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductMn
	for rows.Next() {
		var i ProductMn
		if err := rows.Scan(
			&i.ProductMnID,
			&i.ProductNameMn,
			&i.SCategoryIdMn,
			&i.PriceMn,
			&i.StockQuantity,
			&i.ImagesPathMn,
			&i.DescriptionMn,
			&i.BrandMn,
			&i.ManufacturedCountryMn,
			&i.PenOutputMn,
			&i.FeaturesMn,
			&i.MaterialMn,
			&i.StapleSizeMn,
			&i.CapacityMn,
			&i.WeightMn,
			&i.ThicknessMn,
			&i.PackagingMn,
			&i.UsageMn,
			&i.InstructionsMn,
			&i.ProductCodeMn,
			&i.CostPriceMn,
			&i.RetailPriceMn,
			&i.WarehouseStockMn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByProductIdMn = `-- name: FindByProductIdMn :one
SELECT
    "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
FROM
    "productMn"
WHERE
    "ProductMnID" = $1
LIMIT
    1
`

func (q *Queries) FindByProductIdMn(ctx context.Context, productmnid int32) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, findByProductIdMn, productmnid)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getListProductMn = `-- name: GetListProductMn :many
SELECT
    "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
FROM
    "productMn"
ORDER BY
    "Created_At" DESC
`

func (q *Queries) GetListProductMn(ctx context.Context) ([]ProductMn, error) {
	rows, err := q.db.QueryContext(ctx, getListProductMn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductMn
	for rows.Next() {
		var i ProductMn
		if err := rows.Scan(
			&i.ProductMnID,
			&i.ProductNameMn,
			&i.SCategoryIdMn,
			&i.PriceMn,
			&i.StockQuantity,
			&i.ImagesPathMn,
			&i.DescriptionMn,
			&i.BrandMn,
			&i.ManufacturedCountryMn,
			&i.PenOutputMn,
			&i.FeaturesMn,
			&i.MaterialMn,
			&i.StapleSizeMn,
			&i.CapacityMn,
			&i.WeightMn,
			&i.ThicknessMn,
			&i.PackagingMn,
			&i.UsageMn,
			&i.InstructionsMn,
			&i.ProductCodeMn,
			&i.CostPriceMn,
			&i.RetailPriceMn,
			&i.WarehouseStockMn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductMnWithAllColorsAndSizes = `-- name: GetProductMnWithAllColorsAndSizes :many
SELECT 
    p."ProductMnID",
    p."ProductNameMn",
    p."sCategoryIdMn",
    p."PriceMn",
    p."StockQuantity",
    p."ImagesPathMn",
    p."DescriptionMn",
    p."BrandMn",
    p."ManufacturedCountryMn",
    p."PenOutputMn",
    p."FeaturesMn",
    p."MaterialMn",
    p."StapleSizeMn",
    p."CapacityMn",
    p."WeightMn",
    p."ThicknessMn",
    p."PackagingMn",
    p."UsageMn",
    p."InstructionsMn",
    p."ProductCodeMn",
    p."CostPriceMn",
    p."RetailPriceMn",
    p."WarehouseStockMn",
    p."Created_At",
    p."Updated_At",

    COALESCE(
        ARRAY_AGG(DISTINCT c."ColorId") FILTER (WHERE c."ColorId" IS NOT NULL),
        '{}'
    ) AS "ColorIds",
    COALESCE(
        ARRAY_AGG(DISTINCT c."Color") FILTER (WHERE c."Color" IS NOT NULL),
        '{}'
    ) AS "ColorNames",

    COALESCE(
        ARRAY_AGG(DISTINCT s."SizeId") FILTER (WHERE s."SizeId" IS NOT NULL),
        '{}'
    ) AS "SizeIds",
    COALESCE(
        ARRAY_AGG(DISTINCT s."Size") FILTER (WHERE s."Size" IS NOT NULL),
        '{}'
    ) AS "SizeNames"

FROM "productMn" p
LEFT JOIN "productMn_colors" pc ON p."ProductMnID" = pc."ProductMnID"
LEFT JOIN "productMn_sizes" ps ON p."ProductMnID" = ps."ProductMnID"
LEFT JOIN "Color" c ON pc."ColorId" = c."ColorId"
LEFT JOIN "Size" s ON ps."SizeId" = s."SizeId"
GROUP BY p."ProductMnID"
`

type GetProductMnWithAllColorsAndSizesRow struct {
	ProductMnID           int32
	ProductNameMn         string
	SCategoryIdMn         int32
	PriceMn               string
	StockQuantity         int32
	ImagesPathMn          string
	DescriptionMn         string
	BrandMn               string
	ManufacturedCountryMn string
	PenOutputMn           string
	FeaturesMn            string
	MaterialMn            string
	StapleSizeMn          string
	CapacityMn            string
	WeightMn              string
	ThicknessMn           string
	PackagingMn           string
	UsageMn               string
	InstructionsMn        string
	ProductCodeMn         string
	CostPriceMn           string
	RetailPriceMn         string
	WarehouseStockMn      int32
	CreatedAt             sql.NullTime
	UpdatedAt             sql.NullTime
	ColorIds              interface{}
	ColorNames            interface{}
	SizeIds               interface{}
	SizeNames             interface{}
}

func (q *Queries) GetProductMnWithAllColorsAndSizes(ctx context.Context) ([]GetProductMnWithAllColorsAndSizesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductMnWithAllColorsAndSizes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductMnWithAllColorsAndSizesRow
	for rows.Next() {
		var i GetProductMnWithAllColorsAndSizesRow
		if err := rows.Scan(
			&i.ProductMnID,
			&i.ProductNameMn,
			&i.SCategoryIdMn,
			&i.PriceMn,
			&i.StockQuantity,
			&i.ImagesPathMn,
			&i.DescriptionMn,
			&i.BrandMn,
			&i.ManufacturedCountryMn,
			&i.PenOutputMn,
			&i.FeaturesMn,
			&i.MaterialMn,
			&i.StapleSizeMn,
			&i.CapacityMn,
			&i.WeightMn,
			&i.ThicknessMn,
			&i.PackagingMn,
			&i.UsageMn,
			&i.InstructionsMn,
			&i.ProductCodeMn,
			&i.CostPriceMn,
			&i.RetailPriceMn,
			&i.WarehouseStockMn,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ColorIds,
			&i.ColorNames,
			&i.SizeIds,
			&i.SizeNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductMnWithAllColorsAndSizesByID = `-- name: GetProductMnWithAllColorsAndSizesByID :one
SELECT 
    p."ProductMnID",
    p."ProductNameMn",
    p."sCategoryIdMn",
    p."PriceMn",
    p."StockQuantity",
    p."ImagesPathMn",
    p."DescriptionMn",
    p."BrandMn",
    p."ManufacturedCountryMn",
    p."PenOutputMn",
    p."FeaturesMn",
    p."MaterialMn",
    p."StapleSizeMn",
    p."CapacityMn",
    p."WeightMn",
    p."ThicknessMn",
    p."PackagingMn",
    p."UsageMn",
    p."InstructionsMn",
    p."ProductCodeMn",
    p."CostPriceMn",
    p."RetailPriceMn",
    p."WarehouseStockMn",
    p."Created_At",
    p."Updated_At",

    COALESCE(
        ARRAY_AGG(DISTINCT c."ColorId") FILTER (WHERE c."ColorId" IS NOT NULL),
        '{}'
    ) AS "ColorIds",
    COALESCE(
        ARRAY_AGG(DISTINCT c."Color") FILTER (WHERE c."Color" IS NOT NULL),
        '{}'
    ) AS "ColorNames",

    COALESCE(
        ARRAY_AGG(DISTINCT s."SizeId") FILTER (WHERE s."SizeId" IS NOT NULL),
        '{}'
    ) AS "SizeIds",
    COALESCE(
        ARRAY_AGG(DISTINCT s."Size") FILTER (WHERE s."Size" IS NOT NULL),
        '{}'
    ) AS "SizeNames"

FROM "productMn" p
LEFT JOIN "productMn_colors" pc ON p."ProductMnID" = pc."ProductMnID"
LEFT JOIN "productMn_sizes" ps ON p."ProductMnID" = ps."ProductMnID"
LEFT JOIN "Color" c ON pc."ColorId" = c."ColorId"
LEFT JOIN "Size" s ON ps."SizeId" = s."SizeId"
WHERE p."ProductMnID" = $1
GROUP BY p."ProductMnID"
`

type GetProductMnWithAllColorsAndSizesByIDRow struct {
	ProductMnID           int32
	ProductNameMn         string
	SCategoryIdMn         int32
	PriceMn               string
	StockQuantity         int32
	ImagesPathMn          string
	DescriptionMn         string
	BrandMn               string
	ManufacturedCountryMn string
	PenOutputMn           string
	FeaturesMn            string
	MaterialMn            string
	StapleSizeMn          string
	CapacityMn            string
	WeightMn              string
	ThicknessMn           string
	PackagingMn           string
	UsageMn               string
	InstructionsMn        string
	ProductCodeMn         string
	CostPriceMn           string
	RetailPriceMn         string
	WarehouseStockMn      int32
	CreatedAt             sql.NullTime
	UpdatedAt             sql.NullTime
	ColorIds              interface{}
	ColorNames            interface{}
	SizeIds               interface{}
	SizeNames             interface{}
}

func (q *Queries) GetProductMnWithAllColorsAndSizesByID(ctx context.Context, productmnid int32) (GetProductMnWithAllColorsAndSizesByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductMnWithAllColorsAndSizesByID, productmnid)
	var i GetProductMnWithAllColorsAndSizesByIDRow
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ColorIds,
		&i.ColorNames,
		&i.SizeIds,
		&i.SizeNames,
	)
	return i, err
}

const updateByMnImagePath = `-- name: UpdateByMnImagePath :one
UPDATE
    "productMn"
SET
    "ImagesPathMn" = $1
WHERE
    "ProductMnID" = $2 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type UpdateByMnImagePathParams struct {
	ImagesPathMn string
	ProductMnID  int32
}

func (q *Queries) UpdateByMnImagePath(ctx context.Context, arg UpdateByMnImagePathParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, updateByMnImagePath, arg.ImagesPathMn, arg.ProductMnID)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateByProductMnPrice = `-- name: UpdateByProductMnPrice :one
UPDATE
    "productMn"
SET
    "PriceMn" = $1
WHERE
    "ProductMnID" = $2 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type UpdateByProductMnPriceParams struct {
	PriceMn     string
	ProductMnID int32
}

func (q *Queries) UpdateByProductMnPrice(ctx context.Context, arg UpdateByProductMnPriceParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, updateByProductMnPrice, arg.PriceMn, arg.ProductMnID)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateByProductMnStockQuantity = `-- name: UpdateByProductMnStockQuantity :one
UPDATE
    "productMn"
SET
    "StockQuantity" = $1
WHERE
    "ProductMnID" = $2 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type UpdateByProductMnStockQuantityParams struct {
	StockQuantity int32
	ProductMnID   int32
}

func (q *Queries) UpdateByProductMnStockQuantity(ctx context.Context, arg UpdateByProductMnStockQuantityParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, updateByProductMnStockQuantity, arg.StockQuantity, arg.ProductMnID)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductMn = `-- name: UpdateProductMn :one
UPDATE
    "productMn"
SET
    "ProductNameMn" = $1,
    "sCategoryIdMn" = $2,
    "PriceMn" = $3,
    "StockQuantity" = $4,
    "ImagesPathMn" = $5,
    "DescriptionMn" = $6,
    "BrandMn" = $7,
    "ManufacturedCountryMn" = $8,
    "PenOutputMn" = $9,
    "FeaturesMn" = $10,
    "StapleSizeMn" = $11,
    "CapacityMn" = $12,
    "WeightMn" = $13,
    "ThicknessMn" = $14,
    "PackagingMn" = $15,
    "UsageMn" = $16,
    "InstructionsMn" = $17,
    "ProductCodeMn" = $18,
    "CostPriceMn" = $19,
    "RetailPriceMn" = $20,
    "WarehouseStockMn" = $21
WHERE
    "ProductMnID" = $22 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type UpdateProductMnParams struct {
	ProductNameMn         string
	SCategoryIdMn         int32
	PriceMn               string
	StockQuantity         int32
	ImagesPathMn          string
	DescriptionMn         string
	BrandMn               string
	ManufacturedCountryMn string
	PenOutputMn           string
	FeaturesMn            string
	StapleSizeMn          string
	CapacityMn            string
	WeightMn              string
	ThicknessMn           string
	PackagingMn           string
	UsageMn               string
	InstructionsMn        string
	ProductCodeMn         string
	CostPriceMn           string
	RetailPriceMn         string
	WarehouseStockMn      int32
	ProductMnID           int32
}

func (q *Queries) UpdateProductMn(ctx context.Context, arg UpdateProductMnParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, updateProductMn,
		arg.ProductNameMn,
		arg.SCategoryIdMn,
		arg.PriceMn,
		arg.StockQuantity,
		arg.ImagesPathMn,
		arg.DescriptionMn,
		arg.BrandMn,
		arg.ManufacturedCountryMn,
		arg.PenOutputMn,
		arg.FeaturesMn,
		arg.StapleSizeMn,
		arg.CapacityMn,
		arg.WeightMn,
		arg.ThicknessMn,
		arg.PackagingMn,
		arg.UsageMn,
		arg.InstructionsMn,
		arg.ProductCodeMn,
		arg.CostPriceMn,
		arg.RetailPriceMn,
		arg.WarehouseStockMn,
		arg.ProductMnID,
	)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductMnSubCategory = `-- name: UpdateProductMnSubCategory :one
UPDATE
    "productMn"
SET
    "sCategoryIdMn" = $1
WHERE
    "ProductMnID" = $2 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type UpdateProductMnSubCategoryParams struct {
	SCategoryIdMn int32
	ProductMnID   int32
}

func (q *Queries) UpdateProductMnSubCategory(ctx context.Context, arg UpdateProductMnSubCategoryParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, updateProductMnSubCategory, arg.SCategoryIdMn, arg.ProductMnID)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSProductMn = `-- name: UpdateSProductMn :one
UPDATE
    "productMn"
SET
    "StockQuantity" = $1
WHERE
    "ProductMnID" = $2 RETURNING "ProductMnID", "ProductNameMn", "sCategoryIdMn", "PriceMn", "StockQuantity", "ImagesPathMn", "DescriptionMn", "BrandMn", "ManufacturedCountryMn", "PenOutputMn", "FeaturesMn", "MaterialMn", "StapleSizeMn", "CapacityMn", "WeightMn", "ThicknessMn", "PackagingMn", "UsageMn", "InstructionsMn", "ProductCodeMn", "CostPriceMn", "RetailPriceMn", "WarehouseStockMn", "Created_At", "Updated_At"
`

type UpdateSProductMnParams struct {
	StockQuantity int32
	ProductMnID   int32
}

func (q *Queries) UpdateSProductMn(ctx context.Context, arg UpdateSProductMnParams) (ProductMn, error) {
	row := q.db.QueryRowContext(ctx, updateSProductMn, arg.StockQuantity, arg.ProductMnID)
	var i ProductMn
	err := row.Scan(
		&i.ProductMnID,
		&i.ProductNameMn,
		&i.SCategoryIdMn,
		&i.PriceMn,
		&i.StockQuantity,
		&i.ImagesPathMn,
		&i.DescriptionMn,
		&i.BrandMn,
		&i.ManufacturedCountryMn,
		&i.PenOutputMn,
		&i.FeaturesMn,
		&i.MaterialMn,
		&i.StapleSizeMn,
		&i.CapacityMn,
		&i.WeightMn,
		&i.ThicknessMn,
		&i.PackagingMn,
		&i.UsageMn,
		&i.InstructionsMn,
		&i.ProductCodeMn,
		&i.CostPriceMn,
		&i.RetailPriceMn,
		&i.WarehouseStockMn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
