// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: setAdminPermission.sql

package db

import (
	"context"
	"database/sql"
)

const getPermissionsByAdminID = `-- name: GetPermissionsByAdminID :one
SELECT
    "CanCreate",
    "CanRead",
    "CanUpdate",
    "CanDelete"
FROM
    "adminPermission"
WHERE
    "AdminID" = $1 :: INT
LIMIT 1
`

type GetPermissionsByAdminIDRow struct {
	CanCreate sql.NullBool
	CanRead   sql.NullBool
	CanUpdate sql.NullBool
	CanDelete sql.NullBool
}

func (q *Queries) GetPermissionsByAdminID(ctx context.Context, adminid int32) (GetPermissionsByAdminIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPermissionsByAdminID, adminid)
	var i GetPermissionsByAdminIDRow
	err := row.Scan(
		&i.CanCreate,
		&i.CanRead,
		&i.CanUpdate,
		&i.CanDelete,
	)
	return i, err
}

const setPermissions = `-- name: SetPermissions :exec
INSERT INTO "adminPermission" (
    "AdminID",
    "CanCreate",
    "CanRead",
    "CanUpdate",
    "CanDelete"
) VALUES (
    $1 :: INT,
    $2 :: BOOLEAN,
    $3 :: BOOLEAN,
    $4 :: BOOLEAN,
    $5 :: BOOLEAN
) ON CONFLICT ("AdminID") DO UPDATE SET
    "CanCreate" = EXCLUDED."CanCreate",
    "CanRead" = EXCLUDED."CanRead",
    "CanUpdate" = EXCLUDED."CanUpdate",
    "CanDelete" = EXCLUDED."CanDelete"
`

type SetPermissionsParams struct {
	AdminID   int32
	CanCreate bool
	CanRead   bool
	CanUpdate bool
	CanDelete bool
}

func (q *Queries) SetPermissions(ctx context.Context, arg SetPermissionsParams) error {
	_, err := q.db.ExecContext(ctx, setPermissions,
		arg.AdminID,
		arg.CanCreate,
		arg.CanRead,
		arg.CanUpdate,
		arg.CanDelete,
	)
	return err
}
